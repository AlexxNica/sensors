<pre class="metadata">
Title: Generic Sensor API
Status: ED
Level: 1
ED: https://w3c.github.io/sensors/
Shortname: sensors
TR: http://www.w3.org/TR/sensors/
Editor: Tobie Langel 78102, Intel Corporation, tobie@sensors.codespeaks.com
Editor: Rick Waldron, jQuery Foundation
Group: dap
Abstract:
  This specification defines a framework for exposing sensor data
  to the Open Web Platform in a consistent way.
  It does so by defining a blueprint for writing
  specifications of concrete sensors along with an abstract Sensor interface
  that can be extended to accommodate different sensor types.
Version History: https://github.com/w3c/sensors/commits/gh-pages/index.bs
!Bug Reports: <a href="https://www.github.com/w3c/sensors/issues/new">via the w3c/sensors repository on GitHub</a>
Indent: 2
Markup Shorthands: markdown on
Inline Github Issues: true
Boilerplate: omit issues-index
</pre>
<pre class="anchors">
urlPrefix: https://dom.spec.whatwg.org; spec: DOM
  type: interface
    text: EventTarget; url: interface-eventtarget
urlPrefix: http://www.w3.org/TR/html5/; spec: HTML5
  type: dfn
    urlPrefix: webappapis.html
      text: incumbent settings object
      text: event handlers
      text: event handler event type
  type: interface
    urlPrefix: webappapis.html
      text: EventHandler
urlPrefix: http://w3c.github.io/hr-time/; spec: hr-time-2
  type: interface
    text: DOMHighResTimeStamp; url: dom-domhighrestimestamp
  type: dfn
    text: time origin
urlPrefix: https://w3c.github.io/webappsec/specs/powerfulfeatures/; spec: powerful-features
  type: dfn
    text: secure context
</pre>


Introduction {#intro}
=====================

Increasingly, sensor data is used in application development to
enable new use cases such a geolocation,
counting steps or head-tracking.
This is especially true on mobile devices where new sensors are added regularly.
It is also increasinly common in networked objects
which are part of the Internet of Things.

Exposing sensor data to the Web
has so far been both slow-paced and ad-hoc.
Few sensors are already exposed to the Web.
When they are, it is often in ways that limit their possible use cases
(for example by exposing abstractions that are too high level
and which don't perform well enough).
APIs also vary greatlty from one sensor to the next
which increases the cognitive burden of Web application developers
and slows development.

The goal of the Generic Sensor API is to
promote consistency across sensor APIs,
enable advanced use cases thanks to performant low-level APIs, 
and increase the pace at which new sensors can be exposed to the Web
by simplifying the specification and implementation processes.

Use Cases
=========

Issue(w3c/sensors#12):

Security and privacy considerations
===================================

Secure Context {#secure-context}
--------------

Sensor output is explicitely flagged by the Secure Contexts specification [[powerful-features]] as a high-value target for network attackers. At such, sensor output SHOULD only be available within a <a>secure context</a>.

Issue(w3c/sensors#20):

Terminology
===========

A <dfn>Sensor</dfn> measures physical quantities such as
temperature, acceleration, air pressure or luminosity
and provide a corresponding output.
Examples of sensors include (but are not limited to):
GPS, compass, altimeter, barometer, podometer, thermometer or gyroscope.
A <a lt="conformant user agent">User Agent</a> may expose
different types of sensors and multiple sensors of the same kind.
For example an accelerometer, gyroscope, and
rear and front proximity sensor on a mobile phone.

The output of sensors can be provided as is
or combined with the output of other sensors
through a process called <dfn>sensor fusion</dfn>
to provide higher-level or more accurate data
(often at the cost of increased latency).
For example, the output of a three-axis magnetometer
needs to be combined with the output of an accelerometer
to provide a correct bearing.
Sensor fusion can be carried out at the hardware or software level.

<a>Sensors</a> created through <a>sensor fusion</a> are sometimes
called virtual or synthetic sensors. However, the specification
doesn't make any practical differences between them.

API
===

Issue(w3c/sensors#8):

## The `Sensors` Interface

The <a>Sensors</a> interface represents a container for a list of <a>SensorInfo</a> objects. It is exposed on Window and Workers as the `Window.sensors` and `WorkerGlobalScope.sensors` attribute respectively.

<pre class="idl">
[Constructor, Exposed=(Window,Worker)]
interface Sensors {
  Promise&lt;sequence&lt;SensorInfo&gt;&gt; matchAll(optional MatchAllOptions options);
};

partial interface Window {
  [SameObject] readonly attribute Sensors sensors;
};

partial interface WorkerGlobalScope {
  [SameObject] readonly attribute Sensors sensors;
};

dictionary MatchAllOptions {
  DOMString type;
};
</pre>

### Sensors.matchAll

Issue(w3c/sensors#26):

Returns a promise which resolves to an array of <a>SensorInfo</a> objects representing all available local(?) sensors.

Issue(w3c/sensors#28):

Issue(w3c/sensors#7):

<pre class="example highlight">
sensors.matchAll({ type: "proximity", position: "rear" }).then(function(sensors) {
    let sensor_info = sensors[0];
    if (!sensor_info) return;
    let sensor = new ProximitySensor(sensor_info.id, { /* ... */ });
    sensor.onchange = dostuff;
});
</pre>

## The <dfn>SensorInfo</dfn> Interface

The `SensorInfo` interface is a lightweight object that represents an actual physical sensor. Concrete sensor implementation will need to subclass it.

If no `id` is given, the Constructor uses the identifier of the default sensor of that type. This is to the cater to the common case of having a single sensor of a given type on a device.

<pre class="example highlight javascript">

let sensor = new GeolocationSensor();
sensor.isDefault; // returns true;

</pre>

<pre class="idl">
[Constructor(optional DOMString id, optional SensorInit sensorInitDic), Exposed=(Window,Worker)]
interface SensorInfo {
    readonly attribute DOMString id;
    readonly attribute boolean isDefault;
};

dictionary SensorInit {
  boolean isDefault;
};
</pre>

### <dfn>SensorInfo.id</dnf>

Returns the id of the sensor. This is an opaque DOMString.

### <dfn>SensorInfo.isDefault</dnf>

Returns true if the sensor is the default sensor of that type on the device, false otherwise.

## The <dfn interface>Sensor</dfn> Interface

A `Sensor` object has an associated <a>sensor</a>.

`Sensor` Interface's role is to observe the changes in a given sensor at regular intervals and emit events when those value change in a consumer-configurable way.

Issue(w3c/sensors#14):

<pre class="idl">
[Constructor(SensorInfo info, optional SensorOptions sensorObserverOptions), Exposed=(Window,Worker)]
interface Sensor : EventTarget {
  attribute double frequency;
  attribute boolean batch;
  readonly attribute SensorInfo info;
  attribute TresholdCallback? treshold; 
  attribute double timeout; 
  attribute boolean wakeup; 
  readonly attribute SensorReading? value;
  readonly attribute SensorReading[]? values;
  attribute EventHandler onerror;
  attribute EventHandler onchange;
  // would that cover all cases?
  attribute EventHandler oncalibration;
  // needed?
  attribute EventHandler onconnect;
  attribute EventHandler ondisconnect;
};

dictionary SensorOptions {
  double? frequency;
  boolean? batch = false;
  TresholdCallback? treshold;
  double? timeout;
};

callback TresholdCallback = boolean (SensorReading currentValue, SensorReading newValue);
</pre>

### Sensor.frequency

Issue(w3c/sensors#4):

Issue(w3c/sensors#6):

Issue(w3c/sensors#23):

### Sensor.batch

Returns true if batch mode was requested, false otherwise.

### Sensor.info

Returns the related <a>SensorInfo</a> object.

### Sensor.treshold

Issue(w3c/sensors#25):

### Sensor.timeout

Issue(w3c/sensors#44):

### Sensor.wakeup

Issue(w3c/sensors#15):

### Sensor.value

Issue(w3c/sensors#2):

### Sensor.values

Issue(w3c/sensors#13):

### Sensor.onerror

### Sensor.onchange

### Sensor.oncalibration

### Sensor.onconnect

### Sensor.ondisconnect

### Event handlers

The following are the <a>event handlers</a> (and their corresponding <a>event handler event types</a>) that MUST be supported as attributes by the objects implementing the <a>Sensor</a> interface:

<table class="simple">
  <thead>
    <tr>
      <th>event handler</th>
      <th>event handler event type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code>onchange</code></strong></td>
      <td><code>change</code></td>
    </tr>
    <tr>
      <td><strong><code>onerror</code></strong></td>
      <td><code>error</code></td>
    </tr>
    <tr>
      <td><strong><code>oncalibration</code></strong></td>
      <td><code>calibration</code></td>
    </tr>
    <tr>
      <td><strong><code>onconnect</code></strong></td>
      <td><code>connect</code></td>
    </tr>
    <tr>
      <td><strong><code>ondisconnect</code></strong></td>
      <td><code>disconnect</code></td>
    </tr>
  </tbody>
</table>

### The <dfn>SensorReading</dfn> Interface

Represents the values of a sensor at a given point in time.

<pre class="idl">
interface SensorReading {
  readonly attribute DOMHighResTimeStamp timeStamp;
  readonly attribute SensorInfo info;
};
</pre>

### SensorReading.timeStamp

Returns a timestamp of the time at which the data was <a href=#>read from the sensor</a> expressed in milliseconds that passed since the <a>time origin</a>.

### SensorReading.info

Returns the sensor object the reading is taken from.

Low level Sensor API
--------------------

Issue(w3c/sensors#24):

Extensibility
=============

The purpose of this section is to describe
how this specification can be extended to specify concrete <a>sensors</a>.


Naming
------

<a interface>Sensor</a> interfaces should be
named after their associated <a>sensor</a>.
So for example, the interface associated with a gyroscope
should be simply named `Gyroscope`.
When no such name exist or when such name it too arcane,
the interface should be named by combining
the physical quantity the <a>sensor</a> measures
with the "Sensor" suffix.
For example, a <a>sensor</a> measuring
the distance at which an object is from it
may see its associated interface called `ProximitySensor`.


It will feature precise steps on how to extend or inherit from interfaces described in this specification along with examples for two sensors, one which measures a single value and one which measures multiple ones.

Issue(w3c/sensors#22):

Acknowledgements
================

The following people have greatly contributed to this specification through extensive discussions on GitHub: <span id=gh-commenters></span>.

We'd also like to thank <span id=gh-contributors></span> for their editorial input.

